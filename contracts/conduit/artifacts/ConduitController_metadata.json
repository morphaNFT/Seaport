{
	"compiler": {
		"version": "0.8.17+commit.8df45f5f"
	},
	"language": "Solidity",
	"output": {
		"abi": [
			{
				"inputs": [],
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "CallerIsNotNewPotentialOwner",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "CallerIsNotOwner",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "ChannelOutOfRange",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "ConduitAlreadyExists",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "InvalidCreator",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "InvalidInitialOwner",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "newPotentialOwner",
						"type": "address"
					}
				],
				"name": "NewPotentialOwnerAlreadySet",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "NewPotentialOwnerIsZeroAddress",
				"type": "error"
			},
			{
				"inputs": [],
				"name": "NoConduit",
				"type": "error"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "NoPotentialOwnerCurrentlySet",
				"type": "error"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": false,
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"indexed": false,
						"internalType": "bytes32",
						"name": "conduitKey",
						"type": "bytes32"
					}
				],
				"name": "NewConduit",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "previousOwner",
						"type": "address"
					},
					{
						"indexed": true,
						"internalType": "address",
						"name": "newOwner",
						"type": "address"
					}
				],
				"name": "OwnershipTransferred",
				"type": "event"
			},
			{
				"anonymous": false,
				"inputs": [
					{
						"indexed": true,
						"internalType": "address",
						"name": "newPotentialOwner",
						"type": "address"
					}
				],
				"name": "PotentialOwnerUpdated",
				"type": "event"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "acceptOwnership",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "cancelOwnershipTransfer",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes32",
						"name": "conduitKey",
						"type": "bytes32"
					},
					{
						"internalType": "address",
						"name": "initialOwner",
						"type": "address"
					}
				],
				"name": "createConduit",
				"outputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"internalType": "uint256",
						"name": "channelIndex",
						"type": "uint256"
					}
				],
				"name": "getChannel",
				"outputs": [
					{
						"internalType": "address",
						"name": "channel",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "channel",
						"type": "address"
					}
				],
				"name": "getChannelStatus",
				"outputs": [
					{
						"internalType": "bool",
						"name": "isOpen",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "getChannels",
				"outputs": [
					{
						"internalType": "address[]",
						"name": "channels",
						"type": "address[]"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes32",
						"name": "conduitKey",
						"type": "bytes32"
					}
				],
				"name": "getConduit",
				"outputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"internalType": "bool",
						"name": "exists",
						"type": "bool"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "getConduitCodeHashes",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "creationCodeHash",
						"type": "bytes32"
					},
					{
						"internalType": "bytes32",
						"name": "runtimeCodeHash",
						"type": "bytes32"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "getKey",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "conduitKey",
						"type": "bytes32"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "getPotentialOwner",
				"outputs": [
					{
						"internalType": "address",
						"name": "potentialOwner",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "getTotalChannels",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "totalChannels",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					}
				],
				"name": "ownerOf",
				"outputs": [
					{
						"internalType": "address",
						"name": "owner",
						"type": "address"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "newPotentialOwner",
						"type": "address"
					}
				],
				"name": "transferOwnership",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "conduit",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "channel",
						"type": "address"
					},
					{
						"internalType": "bool",
						"name": "isOpen",
						"type": "bool"
					}
				],
				"name": "updateChannel",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"author": "0age",
			"errors": {
				"CallerIsNotNewPotentialOwner(address)": [
					{
						"details": "Revert with an error when attempting to claim ownership of a conduit      with a caller that is not the current potential owner for the      conduit in question."
					}
				],
				"CallerIsNotOwner(address)": [
					{
						"details": "Revert with an error when attempting to update channels or transfer      ownership of a conduit when the caller is not the owner of the      conduit in question."
					}
				],
				"ChannelOutOfRange(address)": [
					{
						"details": "Revert with an error when attempting to retrieve a channel using an      index that is out of range."
					}
				],
				"ConduitAlreadyExists(address)": [
					{
						"details": "Revert with an error when attempting to create a conduit that      already exists."
					}
				],
				"InvalidCreator()": [
					{
						"details": "Revert with an error when attempting to create a new conduit using a      conduit key where the first twenty bytes of the key do not match the      address of the caller."
					}
				],
				"InvalidInitialOwner()": [
					{
						"details": "Revert with an error when attempting to create a new conduit when no      initial owner address is supplied."
					}
				],
				"NewPotentialOwnerAlreadySet(address,address)": [
					{
						"details": "Revert with an error when attempting to set a new potential owner      that is already set."
					}
				],
				"NewPotentialOwnerIsZeroAddress(address)": [
					{
						"details": "Revert with an error when attempting to register a new potential      owner and supplying the null address."
					}
				],
				"NoConduit()": [
					{
						"details": "Revert with an error when attempting to interact with a conduit that      does not yet exist."
					}
				],
				"NoPotentialOwnerCurrentlySet(address)": [
					{
						"details": "Revert with an error when attempting to cancel ownership transfer      when no new potential owner is currently set."
					}
				]
			},
			"kind": "dev",
			"methods": {
				"acceptOwnership(address)": {
					"params": {
						"conduit": "The conduit for which to accept ownership."
					}
				},
				"cancelOwnershipTransfer(address)": {
					"params": {
						"conduit": "The conduit for which to cancel ownership transfer."
					}
				},
				"constructor": {
					"details": "Initialize contract by deploying a conduit and setting the creation      code and runtime code hashes as immutable arguments."
				},
				"createConduit(bytes32,address)": {
					"params": {
						"conduitKey": "The conduit key used to deploy the conduit. Note that                     the first twenty bytes of the conduit key must match                     the caller of this contract.",
						"initialOwner": "The initial owner to set for the new conduit."
					},
					"returns": {
						"conduit": "The address of the newly deployed conduit."
					}
				},
				"getChannel(address,uint256)": {
					"params": {
						"channelIndex": "The index of the channel in question.",
						"conduit": "The conduit for which to retrieve the open channel."
					},
					"returns": {
						"channel": "The open channel, if any, at the specified channel index."
					}
				},
				"getChannelStatus(address,address)": {
					"params": {
						"channel": "The channel for which to retrieve the status.",
						"conduit": "The conduit for which to retrieve the channel status."
					},
					"returns": {
						"isOpen": "The status of the channel on the given conduit."
					}
				},
				"getChannels(address)": {
					"params": {
						"conduit": "The conduit for which to retrieve open channels."
					},
					"returns": {
						"channels": "An array of open channels on the given conduit."
					}
				},
				"getConduit(bytes32)": {
					"params": {
						"conduitKey": "The conduit key used to derive the conduit."
					},
					"returns": {
						"conduit": "The derived address of the conduit.",
						"exists": " A boolean indicating whether the derived conduit has been                 deployed or not."
					}
				},
				"getConduitCodeHashes()": {
					"details": "Retrieve the conduit creation code and runtime code hashes."
				},
				"getKey(address)": {
					"params": {
						"conduit": "The conduit for which to retrieve the associated conduit                key."
					},
					"returns": {
						"conduitKey": "The conduit key used to deploy the supplied conduit."
					}
				},
				"getPotentialOwner(address)": {
					"params": {
						"conduit": "The conduit for which to retrieve the potential owner."
					},
					"returns": {
						"potentialOwner": "The potential owner, if any, for the conduit."
					}
				},
				"getTotalChannels(address)": {
					"params": {
						"conduit": "The conduit for which to retrieve the total channel count."
					},
					"returns": {
						"totalChannels": "The total number of open channels for the conduit."
					}
				},
				"ownerOf(address)": {
					"params": {
						"conduit": "The conduit for which to retrieve the associated owner."
					},
					"returns": {
						"owner": "The owner of the supplied conduit."
					}
				},
				"transferOwnership(address,address)": {
					"params": {
						"conduit": "The conduit for which to initiate ownership transfer.",
						"newPotentialOwner": "The new potential owner of the conduit."
					}
				},
				"updateChannel(address,address,bool)": {
					"params": {
						"channel": "The channel to open or close on the conduit.",
						"conduit": "The conduit for which to open or close the channel.",
						"isOpen": "A boolean indicating whether to open or close the channel."
					}
				}
			},
			"title": "ConduitController",
			"version": 1
		},
		"userdoc": {
			"kind": "user",
			"methods": {
				"acceptOwnership(address)": {
					"notice": "Accept ownership of a supplied conduit. Only accounts that the         current owner has set as the new potential owner may call this         function."
				},
				"cancelOwnershipTransfer(address)": {
					"notice": "Clear the currently set potential owner, if any, from a conduit.         Only the owner of the conduit in question may call this function."
				},
				"createConduit(bytes32,address)": {
					"notice": "Deploy a new conduit using a supplied conduit key and assigning         an initial owner for the deployed conduit. Note that the first         twenty bytes of the supplied conduit key must match the caller         and that a new conduit cannot be created if one has already been         deployed using the same conduit key."
				},
				"getChannel(address,uint256)": {
					"notice": "Retrieve an open channel at a specific index for a given conduit.         Note that the index of a channel can change as a result of other         channels being closed on the conduit."
				},
				"getChannelStatus(address,address)": {
					"notice": "Retrieve the status (either open or closed) of a given channel on         a conduit."
				},
				"getChannels(address)": {
					"notice": "Retrieve all open channels for a given conduit. Note that calling         this function for a conduit with many channels will revert with         an out-of-gas error."
				},
				"getConduit(bytes32)": {
					"notice": "Derive the conduit associated with a given conduit key and         determine whether that conduit exists (i.e. whether it has been         deployed)."
				},
				"getKey(address)": {
					"notice": "Retrieve the conduit key for a deployed conduit via reverse         lookup."
				},
				"getPotentialOwner(address)": {
					"notice": "Retrieve the potential owner, if any, for a given conduit. The         current owner may set a new potential owner via         `transferOwnership` and that owner may then accept ownership of         the conduit in question via `acceptOwnership`."
				},
				"getTotalChannels(address)": {
					"notice": "Retrieve the total number of open channels for a given conduit."
				},
				"ownerOf(address)": {
					"notice": "Retrieve the current owner of a deployed conduit."
				},
				"transferOwnership(address,address)": {
					"notice": "Initiate conduit ownership transfer by assigning a new potential         owner for the given conduit. Once set, the new potential owner         may call `acceptOwnership` to claim ownership of the conduit.         Only the owner of the conduit in question may call this function."
				},
				"updateChannel(address,address,bool)": {
					"notice": "Open or close a channel on a given conduit, thereby allowing the         specified account to execute transfers against that conduit.         Extreme care must be taken when updating channels, as malicious         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155         tokens where the token holder has granted the conduit approval.         Only the owner of the conduit in question may call this function."
				}
			},
			"notice": "ConduitController enables deploying and managing new conduits, or         contracts that allow registered callers (or open \"channels\") to         transfer approved ERC20/721/1155 tokens on their behalf.",
			"version": 1
		}
	},
	"settings": {
		"compilationTarget": {
			"conduit/ConduitController.sol": "ConduitController"
		},
		"evmVersion": "london",
		"libraries": {},
		"metadata": {
			"bytecodeHash": "ipfs"
		},
		"optimizer": {
			"enabled": false,
			"runs": 200
		},
		"remappings": []
	},
	"sources": {
		"conduit/Conduit.sol": {
			"keccak256": "0xd0a8666160c7c2c1bd74ee4144b0aed727b8a5ee4b3ef9502011bc3e96edd969",
			"license": "MIT",
			"urls": [
				"bzz-raw://f9932acb889d618604c52dfa4f241e5f3f793cf489459bb9b858fc768e05b59b",
				"dweb:/ipfs/QmX5UQnq55ZbxLinZPnbrRfNqg96dugYxkkj628PTh2ZGn"
			]
		},
		"conduit/ConduitController.sol": {
			"keccak256": "0x0261f46d3deeaadf83feafe15d204c83265efa11e628c7ebea3532826f74b73f",
			"license": "MIT",
			"urls": [
				"bzz-raw://09c83ed734429f4a46d03f496be217606cf05e8bf105cb7b1dd1efd16186acb2",
				"dweb:/ipfs/QmRusV16Wv2Ef6P6zE3Cgs6N3Ah6Q3LthDPh5S7j1WSRNq"
			]
		},
		"conduit/lib/ConduitConstants.sol": {
			"keccak256": "0x4b70ada07bfe97fc4cf18e23fbf82831c80ab2251b3ef455b4d0012a980c6f76",
			"license": "MIT",
			"urls": [
				"bzz-raw://71255bb8a6927f7e65d7462b3971eec603ad7e0d72d9a4a4288d2d738ff5a085",
				"dweb:/ipfs/Qma6uCkQdMLE9dKcCTJ9HiChewSPAf3a6mybHSXm9tKxiF"
			]
		},
		"conduit/lib/ConduitEnums.sol": {
			"keccak256": "0x3a9ecf77688f97d1b595be27b49fca3eac93e3f91160d79f0f0063c250fd8aca",
			"license": "MIT",
			"urls": [
				"bzz-raw://d596c21d5c7c7b47ca14908cbd7add9c06898c500cf47988446f843c0b28cf96",
				"dweb:/ipfs/QmZf12Y7XHwEWvjd2ZbaUFz4NXsWPFGJF6vNg1HECvXV5m"
			]
		},
		"conduit/lib/ConduitStructs.sol": {
			"keccak256": "0xfd2cec45327e9a6ebc02d7efb9daa1cfdabb26eb803e4b2e9b5e82340d92cfed",
			"license": "MIT",
			"urls": [
				"bzz-raw://ea7fa97afdf70ab91449e54f9a4f40e9da16292ab87b86e7e975e6d92f573dc3",
				"dweb:/ipfs/QmaRvo6P8YYPYNgcuP4HVV2wqDuVSB1t6AwMe8jMbcQY3F"
			]
		},
		"interfaces/ConduitControllerInterface.sol": {
			"keccak256": "0xc38cd5d6f7f6ea6c94c54ef401d702b352ddf6c907590305c4bf45e9b4fe8f36",
			"license": "MIT",
			"urls": [
				"bzz-raw://7f621875af5c89abd176a57608bd4e4ac4d9e470123a6f531b20eb91ccfc70d1",
				"dweb:/ipfs/QmUgYyDvtPyz3sWYnsjzMtBiZWf6pKiLiYaycs9PpisJdr"
			]
		},
		"interfaces/ConduitInterface.sol": {
			"keccak256": "0xbfcd43fd8c0f3eccfb6b5c10a4c4b794f3004ff08152116f8b1ea6512af336e1",
			"license": "MIT",
			"urls": [
				"bzz-raw://b0409357d577d488ad2ce54d258888cb1001f23d52b8140a19abc873cff15a2e",
				"dweb:/ipfs/QmYPuHK15VEziDVrdCSxFcBFbgHGE9K3BTSmbz1nAjtLBH"
			]
		},
		"interfaces/TokenTransferrerErrors.sol": {
			"keccak256": "0xd547a837e72da776edb433ef6bbb5ab1dbf4bc8e98995ca2baf83edcadd73607",
			"license": "MIT",
			"urls": [
				"bzz-raw://324a3db3d18f679f1d4595d275820a3c320a22ae89b16277a39a548b8ccb36cb",
				"dweb:/ipfs/QmdLhvU1RddvwJKNMYbyXBtMDn5P7J9YQMgpWY1qsYXjjF"
			]
		},
		"lib/TokenTransferrer.sol": {
			"keccak256": "0xfcfa2be72ad8a3c2c096f9dc892b7040b9efc13315fc283ffe1a407d1c974ad3",
			"license": "MIT",
			"urls": [
				"bzz-raw://ce58309f3fddfed9f7b779e3cb99aa629335bd11a3387d9ea52261f87ac1219c",
				"dweb:/ipfs/QmRVH8o3Q7ybgerhqduSGrH9gVemfe2BZbGhTfvBABNtbq"
			]
		},
		"lib/TokenTransferrerConstants.sol": {
			"keccak256": "0xb55807b4999544c4e336a9ea22a963ed50620522b5406d0cd8d5b6d790a2a322",
			"license": "MIT",
			"urls": [
				"bzz-raw://730aa2bca27798a700577ddedd5e7ec4c28d6ade0cefcceb3431af89d65946ed",
				"dweb:/ipfs/QmQeaMEM6e7oTeoa3fjWf1F3Hs2CEh49GK4qN6p4rbaBeR"
			]
		}
	},
	"version": 1
}